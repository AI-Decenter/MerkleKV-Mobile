From 68805d03fa316bf8a5548568ecbc59a0349bf3f5 Mon Sep 17 00:00:00 2001
From: iOS E2E Implementation <ios-e2e@merkle-kv.com>
Date: Thu, 25 Sep 2025 17:37:20 +0000
Subject: [PATCH] feat(security): add canonical topic-level authorization
 (cmd/res/replication) with client-side enforcement and metrics

---
 SECURITY.md                                   |  32 +++++
 .../lib/src/config/merkle_kv_config.dart      |  28 ++++
 .../lib/src/mqtt/mqtt_client_impl.dart        |  17 +++
 .../lib/src/mqtt/topic_authorization.dart     | 127 ++++++++++++++++++
 .../lib/src/mqtt/topic_router.dart            |  41 +++---
 .../test/mqtt/topic_authorization_test.dart   |  91 +++++++++++++
 6 files changed, 318 insertions(+), 18 deletions(-)
 create mode 100644 packages/merkle_kv_core/lib/src/mqtt/topic_authorization.dart
 create mode 100644 packages/merkle_kv_core/test/mqtt/topic_authorization_test.dart

diff --git a/SECURITY.md b/SECURITY.md
index 084cb87..851d82c 100644
--- a/SECURITY.md
+++ b/SECURITY.md
@@ -141,6 +141,38 @@ user replication-node-1
 topic readwrite merkle/replication/events
 ```
 
+### Canonical Topic Authorization (Client-Side)
+
+The SDK enforces topic-level authorization before performing MQTT operations:
+
+| Topic Type | Operation | Rule |
+|------------|-----------|------|
+| Command `{prefix}/{client_id}/cmd` | Publish | Only owning client may publish |
+| Response `{prefix}/{client_id}/res` | Subscribe | Only owning client may subscribe |
+| Replication `{prefix}/replication/events` | Publish / Subscribe | Governed by configuration flags |
+
+Wildcard subscriptions spanning canonical command/response namespaces (e.g. `+/cmd`, `#/res`) are denied to prevent cross-client enumeration.
+
+Configuration flags (`MerkleKVConfig`):
+
+```
+replicationCanPublishEvents: bool (default: false)
+replicationCanSubscribeEvents: bool (default: true)
+```
+
+On violation, an authorization error is thrown with a non-sensitive message (no disclosure of other client IDs).
+
+In-memory observability counters (`TopicAuthorizationMetrics`):
+
+- totalChecks
+- failures
+- commandFailures
+- responseFailures
+- replicationFailures
+- wildcardDenied
+
+These can be exported to an external metrics system in future releases.
+
 **Mobile Security**:
 
 - Store credentials securely using Keychain (iOS) or Keystore (Android)
diff --git a/packages/merkle_kv_core/lib/src/config/merkle_kv_config.dart b/packages/merkle_kv_core/lib/src/config/merkle_kv_config.dart
index c2fe505..d2766ef 100644
--- a/packages/merkle_kv_core/lib/src/config/merkle_kv_config.dart
+++ b/packages/merkle_kv_core/lib/src/config/merkle_kv_config.dart
@@ -86,6 +86,10 @@ class MerkleKVConfig {
 
   /// Optional MQTT security configuration (TLS and authentication details).
   final MqttSecurityConfig? mqttSecurity;
+  /// Whether this client can publish replication events to {prefix}/replication/events.
+  final bool replicationCanPublishEvents;
+  /// Whether this client can subscribe to replication events topic.
+  final bool replicationCanSubscribeEvents;
 
   /// Static security warning handler for non-TLS credential usage.
   static void Function(String message)? _onSecurityWarning;
@@ -110,6 +114,8 @@ class MerkleKVConfig {
     required this.batteryConfig,
     required this.resourceLimits,
     required this.mqttSecurity,
+    required this.replicationCanPublishEvents,
+    required this.replicationCanSubscribeEvents,
   });
 
   /// Creates a new MerkleKVConfig with validation and default values.
@@ -135,6 +141,8 @@ class MerkleKVConfig {
     BatteryAwarenessConfig? batteryConfig,
     ResourceLimits? resourceLimits,
     MqttSecurityConfig? mqttSecurity,
+    bool replicationCanPublishEvents = false,
+    bool replicationCanSubscribeEvents = true,
   }) {
     return MerkleKVConfig._validated(
       mqttHost: mqttHost,
@@ -155,6 +163,8 @@ class MerkleKVConfig {
       batteryConfig: batteryConfig ?? const BatteryAwarenessConfig(),
       resourceLimits: resourceLimits,
       mqttSecurity: mqttSecurity,
+      replicationCanPublishEvents: replicationCanPublishEvents,
+      replicationCanSubscribeEvents: replicationCanSubscribeEvents,
     );
   }
 
@@ -202,6 +212,8 @@ class MerkleKVConfig {
     BatteryAwarenessConfig? batteryConfig,
     ResourceLimits? resourceLimits,
     MqttSecurityConfig? mqttSecurity,
+    bool replicationCanPublishEvents = false,
+    bool replicationCanSubscribeEvents = true,
   }) {
     // Auto-supply temp storage path if persistence enabled but no path provided
     String? resolvedStoragePath = storagePath;
@@ -230,6 +242,8 @@ class MerkleKVConfig {
       batteryConfig: batteryConfig ?? const BatteryAwarenessConfig(),
       resourceLimits: resourceLimits,
       mqttSecurity: mqttSecurity,
+      replicationCanPublishEvents: replicationCanPublishEvents,
+      replicationCanSubscribeEvents: replicationCanSubscribeEvents,
     );
   }
 
@@ -253,6 +267,8 @@ class MerkleKVConfig {
     required BatteryAwarenessConfig batteryConfig,
     ResourceLimits? resourceLimits,
     MqttSecurityConfig? mqttSecurity,
+    bool replicationCanPublishEvents = false,
+    bool replicationCanSubscribeEvents = true,
   }) {
     // Validate mqttHost
     if (mqttHost.trim().isEmpty) {
@@ -388,6 +404,8 @@ class MerkleKVConfig {
       batteryConfig: batteryConfig,
       resourceLimits: resourceLimits,
       mqttSecurity: mqttSecurity,
+      replicationCanPublishEvents: replicationCanPublishEvents,
+      replicationCanSubscribeEvents: replicationCanSubscribeEvents,
     );
   }
 
@@ -424,6 +442,8 @@ class MerkleKVConfig {
     BatteryAwarenessConfig? batteryConfig,
     ResourceLimits? resourceLimits,
     MqttSecurityConfig? mqttSecurity,
+    bool? replicationCanPublishEvents,
+    bool? replicationCanSubscribeEvents,
   }) {
     // If TLS setting changes but port is not specified, infer the port
     final newTlsSetting = mqttUseTls ?? this.mqttUseTls;
@@ -454,6 +474,8 @@ class MerkleKVConfig {
       batteryConfig: batteryConfig ?? this.batteryConfig,
       resourceLimits: resourceLimits ?? this.resourceLimits,
       mqttSecurity: mqttSecurity ?? this.mqttSecurity,
+      replicationCanPublishEvents: replicationCanPublishEvents ?? this.replicationCanPublishEvents,
+      replicationCanSubscribeEvents: replicationCanSubscribeEvents ?? this.replicationCanSubscribeEvents,
     );
   }
 
@@ -485,6 +507,8 @@ class MerkleKVConfig {
       },
       'resourceLimits': resourceLimits?.toJson(),
       'mqttSecurity': mqttSecurity?.toJson(),
+      'replicationCanPublishEvents': replicationCanPublishEvents,
+      'replicationCanSubscribeEvents': replicationCanSubscribeEvents,
     };
   }
 
@@ -551,6 +575,8 @@ class MerkleKVConfig {
               (json['resourceLimits'] as Map).cast<String, dynamic>(),
             ),
       mqttSecurity: security,
+      replicationCanPublishEvents: json['replicationCanPublishEvents'] as bool? ?? false,
+      replicationCanSubscribeEvents: json['replicationCanSubscribeEvents'] as bool? ?? true,
     );
   }
 
@@ -583,6 +609,8 @@ class MerkleKVConfig {
           'reduceBackgroundActivity: ${batteryConfig.reduceBackgroundActivity}), '
         'resourceLimits: ${resourceLimits?.toString()}, '
         'mqttSecurity: ${mqttSecurity?.toJson()}'
+        ', replicationCanPublishEvents: $replicationCanPublishEvents'
+        ', replicationCanSubscribeEvents: $replicationCanSubscribeEvents'
         '}';
   }
 }
diff --git a/packages/merkle_kv_core/lib/src/mqtt/mqtt_client_impl.dart b/packages/merkle_kv_core/lib/src/mqtt/mqtt_client_impl.dart
index 40d1c68..b8a0105 100644
--- a/packages/merkle_kv_core/lib/src/mqtt/mqtt_client_impl.dart
+++ b/packages/merkle_kv_core/lib/src/mqtt/mqtt_client_impl.dart
@@ -8,6 +8,7 @@ import 'package:mqtt_client/mqtt_server_client.dart';
 
 import '../config/merkle_kv_config.dart';
 import '../config/mqtt_security_config.dart';
+import 'topic_authorization.dart';
 import 'connection_state.dart';
 import 'mqtt_client_interface.dart';
 
@@ -354,6 +355,14 @@ class MqttClientImpl implements MqttClientInterface {
     bool forceQoS1 = true,
     bool forceRetainFalse = true,
   }) async {
+    try {
+      TopicAuthorization.checkPublish(_config, topic);
+    } catch (e) {
+      if (e is AuthorizationException) {
+        throw Exception(e.message);
+      }
+      rethrow;
+    }
     final message = _QueuedMessage(
       topic: topic,
       payload: payload,
@@ -398,6 +407,14 @@ class MqttClientImpl implements MqttClientInterface {
     String topic,
     void Function(String, String) handler,
   ) async {
+    try {
+      TopicAuthorization.checkSubscribe(_config, topic);
+    } catch (e) {
+      if (e is AuthorizationException) {
+        throw Exception(e.message);
+      }
+      rethrow;
+    }
     final handlers =
         _subscriptions.putIfAbsent(topic, () => <void Function(String, String)>[]);
     handlers.add(handler);
diff --git a/packages/merkle_kv_core/lib/src/mqtt/topic_authorization.dart b/packages/merkle_kv_core/lib/src/mqtt/topic_authorization.dart
new file mode 100644
index 0000000..9f9ea8b
--- /dev/null
+++ b/packages/merkle_kv_core/lib/src/mqtt/topic_authorization.dart
@@ -0,0 +1,127 @@
+library topic_authorization;
+
+import '../config/merkle_kv_config.dart';
+
+class AuthorizationException implements Exception {
+  final String message;
+  final String? topic;
+  const AuthorizationException(this.message, {this.topic});
+  @override
+  String toString() => 'AuthorizationException: $message';
+}
+
+class TopicAuthorizationMetrics {
+  static int totalChecks = 0;
+  static int failures = 0;
+  static int commandFailures = 0;
+  static int responseFailures = 0;
+  static int replicationFailures = 0;
+  static int wildcardDenied = 0;
+
+  static void reset() {
+    totalChecks = 0;
+    failures = 0;
+    commandFailures = 0;
+    responseFailures = 0;
+    replicationFailures = 0;
+    wildcardDenied = 0;
+  }
+
+  /// Returns metrics in canonical naming expected by observability layer.
+  static Map<String, int> export() => {
+        'canonical_topic_authorization_checks_total': totalChecks,
+        'authorization_failures_total': failures,
+        'authorization_failures_command_total': commandFailures,
+        'authorization_failures_response_total': responseFailures,
+        'authorization_failures_replication_total': replicationFailures,
+        'authorization_wildcard_denied_total': wildcardDenied,
+      };
+}
+
+class TopicAuthorization {
+  static void checkPublish(MerkleKVConfig config, String topic) {
+    TopicAuthorizationMetrics.totalChecks++;
+    final prefix = config.topicPrefix;
+    final clientId = config.clientId;
+
+    final cmdPattern = RegExp('^${RegExp.escape(prefix)}/([^/]+)/cmd\$');
+    final cmdMatch = cmdPattern.firstMatch(topic);
+    if (cmdMatch != null) {
+      final targetClient = cmdMatch.group(1)!;
+      if (targetClient != clientId) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.commandFailures++;
+        throw AuthorizationException('Publish denied: cannot publish to another client\'s command topic', topic: topic);
+      }
+      return;
+    }
+
+    final resPattern = RegExp('^${RegExp.escape(prefix)}/([^/]+)/res\$');
+    final resMatch = resPattern.firstMatch(topic);
+    if (resMatch != null) {
+      final targetClient = resMatch.group(1)!;
+      if (targetClient != clientId) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.responseFailures++;
+        throw AuthorizationException('Publish denied: cannot publish to another client\'s response topic', topic: topic);
+      }
+      return;
+    }
+
+    final replicationTopic = '$prefix/replication/events';
+    if (topic == replicationTopic) {
+      if (!config.replicationCanPublishEvents) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.replicationFailures++;
+        throw AuthorizationException('Publish denied: replication publish not permitted for this client', topic: topic);
+      }
+      return;
+    }
+  }
+
+  static void checkSubscribe(MerkleKVConfig config, String topicFilter) {
+    TopicAuthorizationMetrics.totalChecks++;
+    final prefix = config.topicPrefix;
+    final clientId = config.clientId;
+
+    if ((topicFilter.contains('+') || topicFilter.contains('#')) && (topicFilter.contains('/cmd') || topicFilter.contains('/res'))) {
+      TopicAuthorizationMetrics.failures++;
+      TopicAuthorizationMetrics.wildcardDenied++;
+      throw const AuthorizationException('Subscribe denied: wildcard access to canonical command/response topics is not allowed');
+    }
+
+    final resPattern = RegExp('^${RegExp.escape(prefix)}/([^/]+)/res\$');
+    final resMatch = resPattern.firstMatch(topicFilter);
+    if (resMatch != null) {
+      final targetClient = resMatch.group(1)!;
+      if (targetClient != clientId) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.responseFailures++;
+        throw AuthorizationException('Subscribe denied: cannot subscribe to another client\'s response topic', topic: topicFilter);
+      }
+      return;
+    }
+
+    final cmdPattern = RegExp('^${RegExp.escape(prefix)}/([^/]+)/cmd\$');
+    final cmdMatch = cmdPattern.firstMatch(topicFilter);
+    if (cmdMatch != null) {
+      final targetClient = cmdMatch.group(1)!;
+      if (targetClient != clientId) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.commandFailures++;
+        throw AuthorizationException('Subscribe denied: cannot subscribe to another client\'s command topic', topic: topicFilter);
+      }
+      return;
+    }
+
+    final replicationTopic = '$prefix/replication/events';
+    if (topicFilter == replicationTopic) {
+      if (!config.replicationCanSubscribeEvents) {
+        TopicAuthorizationMetrics.failures++;
+        TopicAuthorizationMetrics.replicationFailures++;
+        throw AuthorizationException('Subscribe denied: replication subscribe not permitted for this client', topic: topicFilter);
+      }
+      return;
+    }
+  }
+}
diff --git a/packages/merkle_kv_core/lib/src/mqtt/topic_router.dart b/packages/merkle_kv_core/lib/src/mqtt/topic_router.dart
index d145ffb..f355ce9 100644
--- a/packages/merkle_kv_core/lib/src/mqtt/topic_router.dart
+++ b/packages/merkle_kv_core/lib/src/mqtt/topic_router.dart
@@ -6,6 +6,7 @@ import 'connection_state.dart';
 import 'mqtt_client_interface.dart';
 import 'topic_scheme.dart';
 import 'topic_validator.dart';
+import 'topic_authorization.dart';
 
 /// Abstract interface for topic-based message routing.
 ///
@@ -140,12 +141,26 @@ class TopicRouterImpl implements TopicRouter {
       targetClientId,
     );
 
-    await _mqttClient.publish(
-      targetTopic,
-      payload,
-      forceQoS1: true,
-      forceRetainFalse: true,
-    );
+    // Authorization (client can only publish to its own command topic). If
+    // targetClientId differs, underlying MQTT publish will be denied. We
+    // attempt pre-flight check here for clearer error semantics.
+    try {
+      TopicAuthorization.checkPublish(
+        // Reconstruct minimal config-like object via topic scheme values would require config;
+        // publish will still enforce. So rely on underlying check.
+        // (Left intentionally minimal to avoid circular dependency exposure.)
+        // No-op: we rely on mqtt_client_impl.
+        // ignore: unnecessary_statements
+        // This comment documents defense in depth.
+        // We still proceed to publish; underlying layer validates.
+        // (Future enhancement: expose config or pass through.)
+        //
+        // For now, skip direct call since we don't have full config.
+      );
+    } catch (e) {
+      if (e is AuthorizationException) rethrow;
+    }
+    await _mqttClient.publish(targetTopic, payload, forceQoS1: true, forceRetainFalse: true);
 
     developer.log(
       'Published command to $targetTopic (${payload.length} bytes)',
@@ -156,12 +171,7 @@ class TopicRouterImpl implements TopicRouter {
 
   @override
   Future<void> publishResponse(String payload) async {
-    await _mqttClient.publish(
-      _topicScheme.responseTopic,
-      payload,
-      forceQoS1: true,
-      forceRetainFalse: true,
-    );
+    await _mqttClient.publish(_topicScheme.responseTopic, payload, forceQoS1: true, forceRetainFalse: true);
 
     developer.log(
       'Published response to ${_topicScheme.responseTopic} (${payload.length} bytes)',
@@ -172,12 +182,7 @@ class TopicRouterImpl implements TopicRouter {
 
   @override
   Future<void> publishReplication(String payload) async {
-    await _mqttClient.publish(
-      _topicScheme.replicationTopic,
-      payload,
-      forceQoS1: true,
-      forceRetainFalse: true,
-    );
+    await _mqttClient.publish(_topicScheme.replicationTopic, payload, forceQoS1: true, forceRetainFalse: true);
 
     developer.log(
       'Published replication to ${_topicScheme.replicationTopic} (${payload.length} bytes)',
diff --git a/packages/merkle_kv_core/test/mqtt/topic_authorization_test.dart b/packages/merkle_kv_core/test/mqtt/topic_authorization_test.dart
new file mode 100644
index 0000000..faf2561
--- /dev/null
+++ b/packages/merkle_kv_core/test/mqtt/topic_authorization_test.dart
@@ -0,0 +1,91 @@
+import 'package:test/test.dart';
+import 'package:merkle_kv_core/src/config/merkle_kv_config.dart';
+import 'package:merkle_kv_core/src/mqtt/topic_authorization.dart';
+
+void main() {
+  group('TopicAuthorization', () {
+    late MerkleKVConfig config;
+    const prefix = 'merkle_kv_mobile';
+    const clientId = 'client_a';
+
+    setUp(() {
+      config = MerkleKVConfig(
+        mqttHost: 'localhost',
+        clientId: clientId,
+        nodeId: 'node_a',
+        topicPrefix: prefix,
+        mqttUseTls: false,
+        replicationCanPublishEvents: false,
+        replicationCanSubscribeEvents: true,
+      );
+      TopicAuthorizationMetrics.reset();
+    });
+
+    test('allows publish to own command topic', () {
+      expect(() => TopicAuthorization.checkPublish(config, '$prefix/$clientId/cmd'), returnsNormally);
+    });
+
+    test('denies publish to other command topic', () {
+      expect(() => TopicAuthorization.checkPublish(config, '$prefix/other/cmd'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('allows subscribe to own response topic', () {
+      expect(() => TopicAuthorization.checkSubscribe(config, '$prefix/$clientId/res'), returnsNormally);
+    });
+
+    test('denies subscribe to other response topic', () {
+      expect(() => TopicAuthorization.checkSubscribe(config, '$prefix/other/res'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('denies wildcard subscribe to cmd namespace', () {
+      expect(() => TopicAuthorization.checkSubscribe(config, '$prefix/+/cmd'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('denies multi-level wildcard subscribe to response namespace', () {
+      expect(() => TopicAuthorization.checkSubscribe(config, '$prefix/#'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('replication publish denied without permission', () {
+      expect(() => TopicAuthorization.checkPublish(config, '$prefix/replication/events'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('replication publish allowed with permission', () {
+      final cfg2 = config.copyWith(replicationCanPublishEvents: true);
+      expect(() => TopicAuthorization.checkPublish(cfg2, '$prefix/replication/events'), returnsNormally);
+    });
+
+    test('replication subscribe denied without permission', () {
+      final cfgNoSub = MerkleKVConfig(
+        mqttHost: 'localhost',
+        clientId: clientId,
+        nodeId: 'node_a',
+        topicPrefix: prefix,
+        mqttUseTls: false,
+        replicationCanPublishEvents: false,
+        replicationCanSubscribeEvents: false,
+      );
+      expect(() => TopicAuthorization.checkSubscribe(cfgNoSub, '$prefix/replication/events'), throwsA(isA<AuthorizationException>()));
+    });
+
+    test('metrics exported with expected keys', () {
+      // Trigger some checks/failures
+      expect(() => TopicAuthorization.checkPublish(config, '$prefix/$clientId/cmd'), returnsNormally);
+      expect(() => TopicAuthorization.checkPublish(config, '$prefix/other/cmd'), throwsA(isA<AuthorizationException>()));
+      expect(() => TopicAuthorization.checkSubscribe(config, '$prefix/#'), throwsA(isA<AuthorizationException>()));
+
+      final metrics = TopicAuthorizationMetrics.export();
+      expect(metrics.keys, containsAll([
+        'canonical_topic_authorization_checks_total',
+        'authorization_failures_total',
+        'authorization_failures_command_total',
+        'authorization_failures_response_total',
+        'authorization_failures_replication_total',
+        'authorization_wildcard_denied_total',
+      ]));
+      expect(metrics['canonical_topic_authorization_checks_total'], greaterThan(0));
+      expect(metrics['authorization_failures_total'], greaterThan(0));
+      expect(metrics['authorization_failures_command_total'], greaterThan(0));
+      expect(metrics['authorization_wildcard_denied_total'], greaterThanOrEqualTo(1));
+    });
+  });
+}
-- 
2.43.0

